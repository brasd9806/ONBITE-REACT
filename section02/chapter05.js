// 1. 원시타입 vs 객체타입
// 원시타입 : Number, String, Boolean 등.. 값 자체로써 변수에 저장되고 복사됨
// -> let p1 = 1; let p2 = p1; 메모리에 p1과 p2가 각각 1로 저장됨
// -> p2 = 2; 로 값을 변경하면 메모리에서 p2가 가리키던게 1을 가리키지 않고, 2를 가리키게됨.
// -> 기존에 p2가 1을 가리키던 그 값은 삭제되지않음. 다만, p2가 가리키던 값이 달라졌을 뿐!
// => 불변값이다.(메모리 값 수정 X)

// 객체타입 : Object, Array, Function 등.. 참조값을 통해 변수에 저장되고 복사됨
// -> let o1 : {name:"이고래"}; let o2 = o1; o1과 o2이 같은 참조값을 바라봄
// -> o2.name : "홍길동";   
// => o2값을 바꾸게되면 참조값이 바뀜. 즉, o1값도 함께 바뀌어버림!
// => 주의점 1. 가변값이다.(메모리 값 수정 O)

// => 그렇다면, 안전하게 복사하려면???
// Spread 연산자 사용!  (깊은복사 방식)
// let o2 = {...o1};   => 새로운 객체를 생성해서 저장(서로 다른 참조값 참조)



// 주의점 2. 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다!!!
let o1 = {name:"이고래"};
let o2 = o1;
let o3 = {...o1};

// 얕은 비교
console.log(o1 === o2); // true    
console.log(o1 === o3); // false

// => 그렇다면 객체를 문자열로 비교하고 싶다면...
// JSON.stringify() : 객체를 문자열로 변환하는 기능

// 깊은 비교
console.log(
    JSON.stringify(o1) === JSON.stringify(o3)
); // true   



// 주의점 3. 배열과 함수도 사실 객체이다!